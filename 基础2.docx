JVM内存模型 需要划分为5个部分：
1.	栈：存放的都是方法中的局部变量，方法的运行一定要在栈中运行。
a)	局部变量：方法的参数，或者方法{}内部的变量；
b)	作用域：一旦超过作用域，立刻从栈中消失。
2.	堆：凡是new出来的东西，都在堆中。
a)	堆内存里面的东西都有一个地址值，16进制；
b)	堆内存里面的数据（成员变量），都有默认值，规则：
i.	整数：0
ii.	浮点数：0.0
iii.	字符：‘\u0000’
iv.	布尔：false
v.	引用类型：null
vi.	String ： null
3.	方法区：存放class相关信息，包含方法的信息；
4.	本地方法栈：与操作系统有关。
5.	寄存器：与CPU有关。

数组
	传参：形参和实参的地址相同。
	返回值：返回值也是地址值。

Array方法类
1.	Array,toString(int[])
2.	Array.sort(int[])

Math包
1.	Abs（double）绝对值
2.	Ceil（double）向上取值
3.	Floor（double）向下取值
4.	Round（double）四舍五入




类（class） 对象/实例（instance） 引用（quote）

对象
	传参：形参和实参的地址相同。
	返回值：返回值也是地址值。


局部变量和成员变量的不同:
1. 定义位置不一样
2. 作用范围不一样
3. 默认值不一样（局部变量没有默认值，要使用必须手动赋值，如果不赋值，使用时会报编译异常）
4. 内存的位置不一样：局部变量在栈内存；成员变量在堆中；
5. 生命周期不一样：对象创建，成员变量诞生；局部变量在栈退的时，会消亡。
方法中的参数是局部变量：可以不赋值的原因是 方法的时候必定会赋值的。


 




封装：将细节信息隐藏起来，对外界不可见

1.	方法就是一种封装；
2.	Private也是一张封装；


This关键字
1.	当方法的局部变量和成员变量重名时，优先使用局部变量；
2.	当使用成员变量需要用 this，起到区分的效果。
3.	通过谁调用，谁就是this。

构造方法：
1.	格式 ： Public 类名(形式参数…..) { }
a)	不能由返回值
b)	一旦写了至少一个构造方法，那么编译器不在赠送；
c)	无参，有参只能实例化时，只能走一个

匿名对象
1.	New Person().setName();
2.	只能使用一次

类方法：
1.	类方法
2.	用static修饰的方法。
3.	由于类方法是属于整个类的，并不属于类的哪儿个对象，所以类方法的方法体中不能有与类的对象有关的内容。即类方法体有如下限制：
a)	类方法中不能引用对象变量；
b)	类方法中不能调用类的对象方法；
c)	在类方法中不能调使用super，this关键字；
d)	类方法不能被覆盖。


String
1.	内容不可变
2.	因为不可变，所以字符串可以共享使用
3.	字符串效果上相当于char[]字符串数组，但是底层原理是byte[]字节数组
4.	创建字符串的三种方式
a)	New String () // 不赋值就是空（什么也没有）
b)	New String(char[] arrr); // 
c)	New String(byte[] arr);
d)	String a = “xxx”;
5.	无论写不写new，只要是双引号“xxx”就是对象。
6.	常量池
a)	只要是 “ ”写的就在常量池中
b)	Jdk1.7开始 常量池就在堆中，“abc”对象由于虚拟机自己创建，然后指向字节数组（“abc”）——> 常量池中的String对象存放的是字节数组的地址值
7.	方法：
a)	concat：拼接
b)	charat(index)：位置下的char
c)	indexof(“llo”):子串先出现的位置，没有就 -1
d)	截取：subString(start ,end) : [start,end) , 包括左，不包括右
e)	tocharArry():转化为字符数组
f)	getBytes():获取底层的字节数据
g)	replace(oldString , new String):旧的字符串替换成新的字符串截取
h)	split()：分隔，返回一个字符串数组

Static关键字
	一旦使用static关键字，是属于类的，所有实例共享一份
	Static不能用在方法内，任意方法内，包括静态方法
	没有static的方法，必须先实例化对象，才能用
	Static方法，如果是实例化对象引用取调用，在编译阶段也会转变成 “类名称.方法”
	对于本类中的方法可以省略类名称，编译时会翻译成“类名称.方法”
	类方法不能访问成员变量
	Static的变量数据存放在方法区中的静态区
	类名修改静态变量全程和堆就没关系

静态代码块
	特点：
	当第一次用到本类时，静态代码块执行唯一（无论多少个实例，只是执行一次）的一次。
	静态的内容优先于非静态的内容执行
	用途：
	典型用途：用来一次性对静态成员变量进行赋值；（例如JDBC）
继承
-	父子相同的变量，优先使用子类的
-	子类中调用自己的成员变量用this，父类的成员变量用super，方法中调用局部变量直接写
-	如果没有，都是向上找，不是向下找。
-	构造方法的访问特点：
	子类构造函数当中默认有一个“super()”,所以一定是先调用父类构造函数，如果不写就免费赠送。
	如果父类写了有参构造：
	子类手动调用super(参数)
	父类写一个无参构造
	Super()语句必须是，子类构造方法的第一句
	不能在子类中多次super()

Super的三种用法：
1.	在子类的成员方法中，访问父类的成员变量；
2.	在子类的成员方法中，访问父类的成员方法；
3.	在子类构造器中，调用父类的构造方法

This的三种用法：
1.	在本类成员方法中，调用本类的成员变量；
2.	在本类成员方法中，调用本类的成员方法；
3.	在本类构造器中，访问本类的另一个构造方法（且必须是第一构造方法（如果有多个））。、
a)	注意：在多个构造方法中，递归嵌套。执行顺序是从里到外执行。
b)	Super（）和this()不能同时使用，因为都必须在第一句执行。
    public Person() {
        this("x");
        System.out.println("调用父类");
    }

    public Person(String a) {
        this("x", "ss");
        System.out.println(a);
    }

    public Person(String name, String s) {
        System.out.println(name + "=" + s);
}




继承的三个特点：
1.	Java语言是单继承
2.	一个类的直接父类只能是一个
3.	可以嵌套继承
4.	父类可以拥有多个子类


抽象：
-	抽象成模棱两可的
 
-	父类调用 method，三角 圆 正方形 各算各的


抽象方法和抽象类
-	抽象方法：加上abstract ，去掉大括号，就是抽象方法；

-	抽象类：pubic abstract class；
	必须有一个子类取继承抽象父类，覆盖重写抽象方法
	抽象类不能直接实例化
	抽象类可以有构造器，但是只能由子类取初始化 
	抽象类可以无抽象方法
	子类也可以是抽象类，里面定义抽象方法；




接口：
-	接口就是标准
-	Public interface 接口名称{}
	接口必须都是Public
	接口的字节码文件依旧是.class
-	Jdk7之前，只能包含 常量和抽象方法
-	Jkd8，还可以包含 默认方法，静态方法
-	jdk9 ，还可以包含私有方法。
-	注意事项：
	接口中的抽象法，必须是public abstract（只写public 也是抽象方法，系统会给添上abstract） ，前缀可以选择性的省略
	接口中方法必须覆盖重写使用。
-	默认方法：jdk 8
	Public default 返回值类型 方法名称（参数列表）{} ： Public default不写也是这个
	目的：是为了解决 接口升级的问题，父接口升级后（新添加方法会导致实现类都实现，比较麻烦），所以出现了默认方法
	也可以覆盖重写：Public 返回值类型 方法名称（参数列表）{}
-	静态方法：jdk 8：提供外界使用
	Public static 返回值类型 方法名称（参数列表）{}
	注意：
	不能通过实现类的实例化引用调用静态方法。（类中的静态方法是可以调用的，注意在编译时，jvm也会将引用转换为类对象）
	使用方法：接口名称.静态方法（参数）
-	私有方法：jdk9
	目的：解决接口中默认方法的冗余代码
	分类：
	普通私有方法：解决多个默认方法直接重复代码问题
	Private 返回值类型 方法名称（参数）{}
	静态私有方法：解决多个静态方法直接重复代码问题、
	Private static 返回值类型 方法名称（参数）{}
	使用私有方法：
	普通私有方法的使用
	在接口的默认方法中直接调用私有方法即可
	静态私有方法的使用
	在接口的静态方法中直接调用私有方法即可
-	接口中的常量:
	必须是public static final三个关键字共同修饰的。可以省略
	实例变量和类变量在不给从初始值时，都会系统给与初始值。
	接口中名称使用大写，下划线分隔
	使用：
	接口名称.常量名 

-	接口之间是可以多继承的
	如果两个父接口的抽象方法重名，没关系
	最后的孩子只会重写一个方法，最后
	Fu2  fu2 = new Impl();  fu2.test();都会走这个实现方法。
	
	如果两个父接口中的默认方法重名，有关系。
	子接口必须重写。




