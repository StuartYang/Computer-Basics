JVM内存模型 需要划分为5个部分：
1.	栈：存放的都是方法中的局部变量，方法的运行一定要在栈中运行。
a)	局部变量：方法的参数，或者方法{}内部的变量；
b)	作用域：一旦超过作用域，立刻从栈中消失。
2.	堆：凡是new出来的东西，都在堆中。
a)	堆内存里面的东西都有一个地址值，16进制；
b)	堆内存里面的数据（成员变量），都有默认值，规则：
i.	整数：0
ii.	浮点数：0.0
iii.	字符：‘\u0000’
iv.	布尔：false
v.	引用类型：null
vi.	String ： null
3.	方法区：存放class相关信息，包含方法的信息；
4.	本地方法栈：与操作系统有关。
5.	寄存器：与CPU有关。

数组
	传参：形参和实参的地址相同。
	返回值：返回值也是地址值。

Array方法类
1.	Array,toString(int[])
2.	Array.sort(int[])

Math包
1.	Abs（double）绝对值
2.	Ceil（double）向上取值
3.	Floor（double）向下取值
4.	Round（double）四舍五入




类（class） 对象/实例（instance） 引用（quote）

对象
	传参：形参和实参的地址相同。
	返回值：返回值也是地址值。


局部变量和成员变量的不同:
1. 定义位置不一样
2. 作用范围不一样
3. 默认值不一样（局部变量没有默认值，要使用必须手动赋值，如果不赋值，使用时会报编译异常）
4. 内存的位置不一样：局部变量在栈内存；成员变量在堆中；
5. 生命周期不一样：对象创建，成员变量诞生；局部变量在栈退的时，会消亡。
方法中的参数是局部变量：可以不赋值的原因是 方法的时候必定会赋值的。


 




封装：将细节信息隐藏起来，对外界不可见

1.	方法就是一种封装；
2.	Private也是一张封装；


This关键字
1.	当方法的局部变量和成员变量重名时，优先使用局部变量；
2.	当使用成员变量需要用 this，起到区分的效果。
3.	通过谁调用，谁就是this。

构造方法：
1.	格式 ： Public 类名(形式参数…..) { }
a)	不能由返回值
b)	一旦写了至少一个构造方法，那么编译器不在赠送；
c)	无参，有参只能实例化时，只能走一个

匿名对象
1.	New Person().setName();
2.	只能使用一次

类方法：
1.	类方法
2.	用static修饰的方法。
3.	由于类方法是属于整个类的，并不属于类的哪儿个对象，所以类方法的方法体中不能有与类的对象有关的内容。即类方法体有如下限制：
a)	类方法中不能引用对象变量；
b)	类方法中不能调用类的对象方法；
c)	在类方法中不能调使用super，this关键字；
d)	类方法不能被覆盖。


String
1.	内容不可变
2.	因为不可变，所以字符串可以共享使用
3.	字符串效果上相当于char[]字符串数组，但是底层原理是byte[]字节数组
4.	创建字符串的三种方式
a)	New String () // 不赋值就是空（什么也没有）
b)	New String(char[] arrr); // 
c)	New String(byte[] arr);
d)	String a = “xxx”;
5.	无论写不写new，只要是双引号“xxx”就是对象。
6.	常量池
a)	只要是 “ ”写的就在常量池中
b)	Jdk1.7开始 常量池就在堆中，“abc”对象由于虚拟机自己创建，然后指向字节数组（“abc”）——> 常量池中的String对象存放的是字节数组的地址值
7.	方法：
a)	concat：拼接
b)	charat(index)：位置下的char
c)	indexof(“llo”):子串先出现的位置，没有就 -1
d)	截取：subString(start ,end) : [start,end) , 包括左，不包括右
e)	tocharArry():转化为字符数组
f)	getBytes():获取底层的字节数据
g)	replace(oldString , new String):旧的字符串替换成新的字符串截取
h)	split()：分隔，返回一个字符串数组

Static关键字
	一旦使用static关键字，是属于类的，所有实例共享一份
	Static不能用在方法内，任意方法内，包括静态方法
	没有static的方法，必须先实例化对象，才能用
	Static方法，如果是实例化对象引用取调用，在编译阶段也会转变成 “类名称.方法”
	对于本类中的方法可以省略类名称，编译时会翻译成“类名称.方法”
	类方法不能访问成员变量
	Static的变量数据存放在方法区中的静态区
	类名修改静态变量全程和堆就没关系

静态代码块
	特点：
	当第一次用到本类时，静态代码块执行唯一（无论多少个实例，只是执行一次）的一次。
	静态的内容优先于非静态的内容执行
	用途：
	典型用途：用来一次性对静态成员变量进行赋值；（例如JDBC）
继承
-	父子相同的变量，优先使用子类的
-	子类中调用自己的成员变量用this，父类的成员变量用super，方法中调用局部变量直接写
-	如果没有，都是向上找，不是向下找。
-	构造方法的访问特点：
	子类构造函数当中默认有一个“super()”,所以一定是先调用父类构造函数，如果不写就免费赠送。
	如果父类写了有参构造：
	子类手动调用super(参数)
	父类写一个无参构造
	Super()语句必须是，子类构造方法的第一句
	不能在子类中多次super()

Super的三种用法：
1.	在子类的成员方法中，访问父类的成员变量；
2.	在子类的成员方法中，访问父类的成员方法；
3.	在子类构造器中，调用父类的构造方法

This的三种用法：
1.	在本类成员方法中，调用本类的成员变量；
2.	在本类成员方法中，调用本类的成员方法；
3.	在本类构造器中，访问本类的另一个构造方法（且必须是第一构造方法（如果有多个））。、
a)	注意：在多个构造方法中，递归嵌套。执行顺序是从里到外执行。
b)	Super（）和this()不能同时使用，因为都必须在第一句执行。
    public Person() {
        this("x");
        System.out.println("调用父类");
    }

    public Person(String a) {
        this("x", "ss");
        System.out.println(a);
    }

    public Person(String name, String s) {
        System.out.println(name + "=" + s);
}




继承的三个特点：
1.	Java语言是单继承
2.	一个类的直接父类只能是一个
3.	可以嵌套继承
4.	父类可以拥有多个子类


抽象：
-	抽象成模棱两可的
 
-	父类调用 method，三角 圆 正方形 各算各的


抽象方法和抽象类
-	抽象方法：加上abstract ，去掉大括号，就是抽象方法；

-	抽象类：pubic abstract class；
	必须有一个子类取继承抽象父类，覆盖重写抽象方法
	抽象类不能直接实例化
	抽象类可以有构造器，但是只能由子类取初始化 
	抽象类可以无抽象方法
	子类也可以是抽象类，里面定义抽象方法；




接口：
-	接口就是标准
-	Public interface 接口名称{}
	接口必须都是Public
	接口的字节码文件依旧是.class
-	Jdk7之前，只能包含 常量和抽象方法
-	Jkd8，还可以包含 默认方法，静态方法
-	jdk9 ，还可以包含私有方法。
-	注意事项：
	接口中的抽象法，必须是public abstract（只写public 也是抽象方法，系统会给添上abstract） ，前缀可以选择性的省略
	接口中方法必须覆盖重写使用。
-	默认方法：jdk 8
	Public default 返回值类型 方法名称（参数列表）{} ： Public default不写也是这个
	目的：是为了解决 接口升级的问题，父接口升级后（新添加方法会导致实现类都实现，比较麻烦），所以出现了默认方法
	也可以覆盖重写：Public 返回值类型 方法名称（参数列表）{}
-	静态方法：jdk 8：提供外界使用
	Public static 返回值类型 方法名称（参数列表）{}
	注意：
	不能通过实现类的实例化引用调用静态方法。（类中的静态方法是可以调用的，注意在编译时，jvm也会将引用转换为类对象）
	使用方法：接口名称.静态方法（参数）
-	私有方法：jdk9
	目的：解决接口中默认方法的冗余代码
	分类：
	普通私有方法：解决多个默认方法直接重复代码问题
	Private 返回值类型 方法名称（参数）{}
	静态私有方法：解决多个静态方法直接重复代码问题、
	Private static 返回值类型 方法名称（参数）{}
	使用私有方法：
	普通私有方法的使用
	在接口的默认方法中直接调用私有方法即可
	静态私有方法的使用
	在接口的静态方法中直接调用私有方法即可
-	接口中的常量:
	必须是public static final三个关键字共同修饰的。可以省略
	实例变量和类变量在不给从初始值时，都会系统给与初始值。
	接口中名称使用大写，下划线分隔
	使用：
	接口名称.常量名 

-	接口之间是可以多继承的
	如果两个父接口的抽象方法重名，没关系
	最后的孩子只会重写一个方法，最后
	Fu2  fu2 = new Impl();  fu2.test();都会走这个实现方法。
	
	如果两个父接口中的默认方法重名，有关系。
	子接口必须重写。



多态
一个对象（注意不是类）拥有多个形态，
-	继承：学生对象既拥有父类的person的形态，也有自己的形态（父类引用指向子类对象）
	（接口名）父类 对象名 = new 子类名（）；
-	多态中成员变量的访问特点：
	直接 优先访问自己的成员方法，没有向上找
	间接通过成员方法访问成员变量，该方法属于谁就优先访问自己的成员变量，没有向上找。
-	多态的好处
	等号左边就统一了，无论右边new的时候换成哪个子类，等号右边调用方法不会变化。
-	对象向上转型
	父类名称 对象名 = new 子类名称（）；
	含义：右侧创建一个子类，则把它当做父类来看待使用。
	向上转型一定是安全的。（由小范围转向大范围）
-	对象向下转型
	对象一旦向上转型为父类，那么就无法调用子类原有本持的方法。
	解决方法：那用对象的向下转型（还原）
	子类名称 对象名 = （子类名称）父类对象名称。
	如果该类不是子类的父类，去做转换会出现：编译不报错，运行出现异常（ClassECastxception 类转换异常）。
	用instanceof进行判断是否是父类的子类
	If(animal instanceof Dog){} // 判断父类引用本来是不是狗









Final关键字
-	最终的，不可改变的
-	用途：
	可以修饰一个类：
	Public final class 类名称{} //当前类不能有任何子类（太监类），但是可以有父类（任意一个类，都隐含的extends Object）
	一个类如果是final的，那么其中所有的成员方法都无法覆盖重写（因为儿子）
	可以修饰一个方法
	修饰符 final 返回值类型 方法名（）{} // 这个方法就是最终方法，不可以覆盖重写。
	可以修饰一个局部变量
	方法的大括号中
	一旦使用final修饰局部变量（只能赋值一次，先声明，再赋值也可以），那么这个变量不能进行更改。 // “一次赋值，终身不变”。// 就算一样的赋值也不行。
	不可变：
	对于基本类型，不可变说的是变量中的数据不可变
	对于引用类型，不可变说的是变量中的引用不可变，所有引用所执行的数据是可变的。
	可以修饰一个成员变量
	由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值了。
	对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值。
	必须保证所有重载的构造方法，都对final的的成员变量进行赋值。
-	对于类和方法而言：abstract和final不能同时使用（一个方法同时出现abstract和final），因为矛盾。



权限修饰符

Public	 protected	  (default)	  private
同一个类		 1			1			1			1
同包（任意类）	 1			1			1			0
不同包子类		 1			1			0			0
不同包非父子关系 1			0			0			0

•	protected的可见性在于两点：
•	基类的protected成员是包内可见的，并且对包内的子类可见；
•	若子类与基类不在同一包中，那么在子类中，子类实例可以访问其从基类继承而来的protected方法，而不能访问基类实例的protected方法。


内部类
-	一个事物的内部包含另一个事物，那么这就是一个类内部包含着另一个类。
-	例如：身体和心脏的关系。
-	分类：
	成员内部类
	局部内部类（包含匿名内部类）
-	成员内部类：
-	修饰符 class 外部类名称{
修饰符 class 内部类名称{

}

}
	注意：
	内用外，随意访问
	外用内，一定需要借助内部类对象
	内部类编译后的class文件：外部类名称$内部类名称
	使用：
	间接使用：外部类的方法中使用内部类：new 内部类（）.内部类方法（）； // 匿名对象。 //通过外部类的对象，调用外部类的方法，里面间接再使用内部类。
	直接使用：外部名称.内部名称 对象名 = new 外部名称（）.new 内部类名称（）；
	内外类同名变量访问规则：
	内部调用外部类的成员变量：外部类名称.this.成员变量
-	局部内部类：
	一个类定义在一个方法中，只能所属的方法才能访问，出了这个方法不能访问。
	方法体内{class 局部内部名称{} } ，只能在方法体内使用。内部类的创建只能在该方法中。
-	内部类的修饰符规则：
	外部类：public ， default
	Protected的本质是在于继承关系，然而外部类已经作为最外层了，没有继承关系，也就不会有protected修饰。
	Private修饰类，只能自己是实例化自己，外部类的本质就是方便其他类调用，从而失去了外部类的设计之初。
	子类重写父类方法时，方法的访问权限不能比父类方法低
	内部类：
	成员内部类：public/private/default/protected
	局部内部类：什么也不能写



局部内部类的final问题：
-	成员方法中局部变量设置为final（JDK  8 final可以省略），才能让局部内部类方法。


匿名内部类：
-	使用场景：如果接口的实现只使用一次，建议使用匿名内部类。
-	New 接口名（）{重写方法}；
-	注意事项：
	如果希望多次使用，不要使用匿名内部类；
	链式调用，是将方法1的值作为参数传递给方法2。
	匿名内部类无法调用第二个方法。

Java.Uti.Date类：
-	Data data = new Date();//获取系统的日期和时间（未转换 CST中国标准时间）
-	Data data = new Date(毫秒值) ; // 毫秒值转换为Data时间（从1970年开始加）
-	new Date().getTime(); // 与System.CurrentMillLis 一样
-	System.CurrentMillLis（）； // 获取系统从1970年1月1日经历多少毫秒。

Jaa.text.DateFormat类：
-	dateFormat是一个抽象类，可以使用它的子类SimpleDateFormat
-	yyyy-MM-dd  HH:mm:ss，写对应的模式，会见模式替换成对应的时间和日期。
-	模式中的字母不能更改，连接模式的字符更改
-	使用：
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");
        Date date = new Date();

        /*
        格式化 时间
         */
        String str = simpleDateFormat.format(date);
        System.out.println(str);

        /**
         * 字符串转换为日期,如果字符串和构造方法中模式不一样，会抛出异常ParseException，要不跑出去，跑不try...catch
         */

        Date date1 = simpleDateFormat.parse("2022年04月06日 11:48:02");




Calendar类：
-	Calendar是抽象类，无法直接创建对象使用
-	Calendar.getInstance(); // getInstance静态方法直接返回一个 实例对象。
-	常用方法：
        /**
         * 常用方法：
         * 1. int get(int field):返回给定日历字段的值
         * 2. void set(int field , int amount):将给定的日历字段设置为给定值
         * 3. void add(int field , int amount):根据日历的规则，为给定日历字段添加或减去指定的时间量
         * 4. Date getTime():返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象
         *
         * int filed ： 可以采用Calendar的静态变量获取
         *
         */
        Calendar calendar = Calendar.getInstance();
        // Date date1 = calendar.get(Calendar.DATE);/
        calendar.set(Calendar.YEAR,9999); // 重载方法可以将年月日同时设置
        calendar.add(Calendar.YEAR,-2); // 当前年减去2年
        calendar.add(Calendar.YEAR,2); // 当前年加去2年
        Date date2 =  calendar.getTime(); // 日历对象转换为日期对象


Java.lang.System类：
-	不用导包
-	 常用方法：
	System.currentTimeMillis() // 返回毫秒为单位的当前时间
	System.arraycopy(Object src,  int  srcPos, Object dest, int destPos,int length)  //复制数组
	Src：源数组
	srcPos：源数组的起始位置
	dest：目标数组
	destPos：目标起始位置
	length：长度








装箱和拆箱
-	装箱：int——>integer
	new Interger (1)
	Interger.valueof(1)
-	拆箱：integer——>int
	Int a = 对象引用.intValue（）；

自动拆箱和装箱
-	Jdk1.5之后
-	自动装箱：Interger a =1; // 直接将int赋值给Interger
	直接赋值
	arryList直接存放数据
-	自动拆箱：Interger无法参与运算们可以自动转换为基本数据类型
	Interger运算
	arryList直接取值（赋值）

基本数据类型 与 字符串相互转换
-	对应包装类.PraseXxx(字符串)  // 除了Character
-	转换为字符串：
	最常用：基本数据类型+“”
	对应包装类.toString方法



范型（未知）
-	T：type ；E:Element
-	

ArrayList<T> list = new ArrayList<>();
-	在创建集合的时候，就会确定范型的数据类型
-	使用范型的特点：适合不适用范型，默认是Object，可以存储任意类型的数据
	好处：
	避免了类型转换的麻烦，存储的是什么类型，取出的就是什么类型。
	把运行期异常提升到了编译期（写代码的时候）。
	缺点：
	不安全，会引发异常。
	范型是什么，只能存储什么。
-	使用
	类上：创建时确定范型的数据类型
	方法上：调用方法时确定范型的类型
-	范型的通配符
	不知道什么类型来接受时，可以使用?表示未知通配符。
	此时只能接受数据，不能往集合中存储数据。即遍历可以使用，但是存值。
    public void ma(ArrayList<?> arrayList) {
      Iterator<?> iterator =  arrayList.iterator();
      while (iterator.hasNext()){
          System.out.println(iterator.next());
      }
}
-	受限范型
	范型的上限限定
	？extends T ： 代表使用的范型只能T类型的子类/本身
	范型的下限限定
	？ super T：代表使用的范型只能是T类型的父类/本身


异常体系
-	父（超）类java.lang.Throwable 
	子类java.lang.Error：尽量避免，无法处理
	OutOfMemoryError，类定义错误（NoClassDefFoundError）
	子类java.lang.Exception：使用不当导致的，可以解决的问题
	编译期异常（写代码时期）：RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。
	试图使用空值对象引用、除数为零或数组越界
	子子类java.lang.RuntimeException：运行期异常（运行过程中出现的问题）, 一般是由程序逻辑错误引起的。
	运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。但是有了异常解决会避免这个问题。
	NullPointerException(空指针异常)、IndexOutOfBoundsException
-	异常产生过程解析
1.	错误信息由JVM产生，先上抛，main最终不解决，由JVM去处理（报错，中断程序）。
-	Throw
	写在方法内部
	后面的new对象必须是Exception或者Exception的子类
	工作中先对参数进行校验，如果有错就抛给调用者。
	抛出异常对象为结束，后面的代码不会再执行
-	Throws
	交给别人处理
	作用：
	当方法内抛出异常的时候，那么我们就必须出来这个异常；
	可以使用throws关键字处理异常，会把异常对象声明抛出给方法的调用者处理，最终交给JVM处理——>中断处理。
	必须写在方法声明处；
	throws是方法可能抛出异常的声明。(用在声明方法时，表示该方法可能要抛出异常)
-	区别
	Throws是一种趋向
	Thorw的执行会变成一种现实

ThrowAble的3个处理错误方法：
-	getMeage（）：错误的简单信息
-	toString（）：什么错误+详细字符串
-	printStackTrance（）：最全的信息

finally：
-	不能单独使用
-	一般用于资源回收
-	如果finally中有return语句，永远返回finally中的结果，避免这种情况。



多个异常如何处理：
-	一段代码多个try…catch处理
-	多个异常一次性处理，try…catch嵌套，由内到外的处理异常，多个try嵌套，里面的异常是外边的子类（多态导致的）
-	多个异常写一个Exception

父子类异常：
1.	父类有异常，子类重写父类方法时，可以声明抛出和父类相同的异常；
2.	父类有异常，子类重写父类方法时，可以声明抛出父类异常的子类；
3.	父类有异常，子类重写父类方法时，可以不声明抛出异常；
4.	父类没有异常，子类也不能抛出异常，如果异常只能捕获处理，不能抛出。

自定义异常：
Extends Exception/RuntimeException
