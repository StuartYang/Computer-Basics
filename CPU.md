# CPU

[toc]



## 指令系统

### 指令格式

![image-20210927093133700](CPU.assets/image-20210927093133700.png)

- **地址码**：被操作的信息（指令或数据）的地址；
- **操作码**：指令中该指令应该执行什么性质的操作和具有何种功能；
- 指令字长取决于 操作码的长度 + 操作数地址码的长度和个数；



> ​	指令字长和指令字长的关系？
>
> 指令长度与机器字长没有固定的关系：
>
> - 单字长指令：指令长度 = 机器字长；
> - 半字长指令：指令长度 = $\frac{1}{2}$ 机器字长
> - 双字长指令：指令长度 = $2$ 机器字长



### 指令分类

| 名称       | 图解                                                         | 说明                                                         | 案例                                                         |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 零地址指令 | ![image-20210927101455274](CPU.assets/image-20210927101455274.png) | 仅用在堆栈计算机中：两个操作数隐含地从栈顶和次栈顶弹出，送到运算器进行运算，运算结果再隐含的压入堆栈。 | 空操作指令；停机指令；关中断指令；                           |
| 一地址指令 | ![image-20210927101735962](CPU.assets/image-20210927101735962.png) | 指令字长为32 位，操作码占8 位， 1个地址码字段占24 位，则指令操作数的直接寻址范围为2^24^ = 16M 。 | $0P(A_1)—>A_1$加1、减1、求反、求补指令                       |
| 二地址指令 | ![image-20210927111538793](CPU.assets/image-20210927111538793.png) | 若指令字长为32 位，操作码占8 位，两个地址码字段各占12 位， 则指令操作数的直接寻址范围为2^12^ = 4K 。 | $(A_1)0P(A_2)—>A_1$常用的算术和逻辑运算指令，往往要求使用两个操作数，需分别给出目的操作数和源操作数的地址，其中目的操作数地址还用于保存本次的运算结果； |
| 三地址指令 | ![image-20210927111714822](CPU.assets/image-20210927111714822.png) | 若指令字长为32 位，操作码占8 位， 3 个地址码字段各占8 位，则指令操作数的直接寻址范围为2^8^ = 256 | $(A_1)0P(A_2)—>A_3$若地址字段均为主存地址，则完成一条三地址需要4 次访问存储器（取指令1次，取两个操作数2 次，存放结果1 次）。 |
| 四地址指令 | ![image-20210927112021891](CPU.assets/image-20210927112021891.png) | 指令字长为32 位，操作码占8 位， 4 个地址码字段各占6 位，则指令操作数的直接寻址范围为2^6^ = 64 。 | $(A_1)0P(A_2) —>A3$, A~4~ 指出下一条将要执行指令的地址。     |



**分类二**

- **定长操作码指令格式**：最高位部分分配固定的若干位（定长）表示操作码。一般**n位操作码字段**的指令系统最大能够表示$2^n$ 条指令;
- **扩展操作码指令格式**: 指令长度不变，减少地址码的长度用作增加操作码的长度；
  - ![image-20210927112558500](CPU.assets/image-20210927112558500.png)
  - 要求：
    - 不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分的代码相同。
    - 各指令的操作码一定不能重复。
  - 说明：**使用频率高**的指令分配**较短的操作码**；

### 寻址



#### 指令寻址

指令寻址方式有两种：

-  顺序寻址方式：可通过程序计数器(PC) 加1 (1 个指令字长），自动形成下一条指令的地址；

-  跳跃寻址方式：通过转移类指令实现。

   - **下条指令的地址码由本条指令给出下条指令地址的计算方式**
   - 注意：是否跳跃可能受到状态寄存器和操作数的控制：
     - 跳跃到的地址分为绝对地址（由标记符直接得到）和相对地址（相对于当前指令地址的偏移量），跳跃的结果是当前指令修改PC 值，所以**下一条指令仍然通过程序计数器(PC) 给出**。

#### 数据寻址

> 如何在指令中表示一个操作数的地址。

  数据寻址的方式比较多，为了区别，在指令字段中设置一个字段，用来指明属于那种寻址方式：

![image-20210927113539664](CPU.assets/image-20210927113539664.png)

| 寻址名称       |                             图解                             | 说明                                                         |
| -------------- | :----------------------------------------------------------: | ------------------------------------------------------------ |
| 隐含寻址       | ![image-20210927113625168](CPU.assets/image-20210927113625168.png) | 单地址指令中其中另一个地址存在于ACC中；                      |
| 立即寻址       | ![image-20210927114259036](CPU.assets/image-20210927114259036.png) | 地址字段指出就是操作数本身，又称立即数                       |
| 直接寻址       | ![image-20210927114310020](CPU.assets/image-20210927114310020.png) | 指令在执行阶段仅访问一次主存，不需要专门计算操作数的地址；   |
| 间接寻址       | ![image-20210927114334463](CPU.assets/image-20210927114334463.png) | 指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址所在的存储单元的地址，也就是操作数地址的地址 |
| 寄存器寻址     | ![image-20210927114440050](CPU.assets/image-20210927114440050.png) |                                                              |
| 寄存器间接寻址 | ![image-20210927114458357](CPU.assets/image-20210927114458357.png) |                                                              |
| 相对寻址       | ![image-20210927114513597](CPU.assets/image-20210927114513597.png) | EA=(PC)+A ；A 是相对千当前指令地址的位移量，可正可负，补码表示， |
| 基址寻址       | ![image-20210927114639434](CPU.assets/image-20210927114639434.png) | EA= (BR)+ A 。其中基址寄存器既可采用专用寄存器，又可采用通用寄存器。面向操作系统的，其内容由操作系统或管理程序确定，主要用千解决程序逻辑空间与存储器物理空间的无关性，在程序执行过程中，基址寄存器的内容不变（作为基地址），形式地址可变（作为偏移量），采用通用寄存器作为基址寄存器时，可由用户决定哪个寄存器作为基址寄存器，但其内容仍由操作系统确定。因此有利于多道程序设计，并可用千编制浮动程序， |
| 变址寻址       | ![image-20210927114837403](CPU.assets/image-20210927114837403.png) | IX 为变址寄存器（专用），也可用通用寄存器作为变址寄存器。变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可由用户改变（作为偏移量），形式地址A 不变（作为基地址）。处理数组，优点是可扩大寻址范围。 |
| 堆栈寻址       |  寄存器堆栈又称硬堆栈；从主存中划出一段区域来做堆栈是软堆栈  | 堆栈存储器（或专用寄存器组）中一块特定的、按后进先出(LIFO) 原则管理的存储区；堆栈的地址是堆栈指针（SP）【特定的寄存器】给出。采用堆栈结构的计算机系统中，大部分指令表面上都表现为无操作数指令的形式，因为操作数地址都隐含使用了SP，在读／写堆栈中的一个单元的前后都伴有**自动**完成对SP内容的增量或减量操作。 |

![image-20210927114047846](CPU.assets/image-20210927114047846.png)



### CISC 和RISC

![image-20210927151031576](CPU.assets/image-20210927151031576.png)

### 指令执行过程

指令周期：CPU从主存中取出并执行一条指令的时间称作指令周期。

- 不同指令的指令周期不同；
- 1个指令周期 = n个机器周期 ； 一个机器周期 = m个时钟周期（节拍）



一个较为完整的指令周期：

![image-20210927161356368](CPU.assets/image-20210927161356368.png)

- 取指周期是为了取指令；
- 间址周期是为了取有效地址；
- 执行周期是为了取操作数；
- 中断周期是为了保存程序断点；

为了区别不同的工作周期，在CPU 内设置4 个标志触发器FE 、IND 、EX 和INT, 它们分别对应取指、间址、执行和中断周期，并以“1" 状态表示有效，分别由1——>FE 、1——>IND 、1——>EX和1——>INT 这4 个信号控制。

注意：中断周期中的进栈操作是将SP 减1, 这和传统意义上的进栈操作相反，原因是计算机的堆栈中都是向低地址增加，所以进栈操作是减1 而不是加1 。



### 指令流水线

> 一条指令周期通常包括几个时间段（执行步骤），每个步骤完成指令的一部分功能，几个步骤的配合完成整条指令功能。所以不同的步骤执行方案可以尽可能的节省性能和硬件成本。

- 方案一：单指令周期：对所有指令都选用**相同的执行时间**来完成；指令之间串行执行；
- 方案二：多指令周期：不同的步骤中采用自己的所需的时钟周期；指令之间串行执行；
- 方案三：指令流水线：指令之间可以并行执行；力争在**每个时钟脉冲周期完成一条指令的执行过程**；尽量让多条指令同时运行，但各自处在不同的执行步骤中。



注意：指令流水和指令周期中的步骤无关，指令流水在意的是力争在每一个时钟脉冲完成一条指令。



流水线的定义：将指令的执行过程分成多个阶段；

![image-20210927162431612](CPU.assets/image-20210927162431612.png)

- 取指（取址周期）：根据PC 内容访问主存储器，取出一条指令送到IR 中。
- 分析（间址周期）：对指令操作码进行译码，按照给定的寻址方式和地址字段中的内容形成操作数的有效地址EA, 并从有效地址EA 中取出操作数。
- 执行（指向周期）：根据操作码字段，完成指令规定的功能，即把运算结果写到通用寄存器或主存中。



执行方案的选取：

![image-20210927162628695](CPU.assets/image-20210927162628695.png)



$T = 3nt - 2（n-1）t$

其中：

- n是指令条数
- t是每个阶段所需时间
- (n -1)是折叠的部分数



流水线的特点：

- 每个部件后面都有一个缓存寄存器（锁存器），作用是保存本流水段的执行结构供给下一流水段使用；
- 流水线中各功能段的时间应尽量相等，否则将引起堵塞、断流。
- 流水线需要有装入时间和排空时间。

流水线的分类：

- 动态流水线和静态流水线
  - 静态流水线指在同一时间内，流水线的各段只能按同一种功能的连接方式工作。
  - 动态流水线指在同一时间内，当某些段正在实现某种运算时，另一些段却正在进行另一种运算。
- 线性流水线和非线性流水线
  - 线性流水线中，从输入到输出，每个功能段只允许经过一次，不存在反馈回路
  - 非线性流水线存在反馈回路，从输入到输出的过程中， 某些功能段将数次通过流水线，这种流水线适合进行线性递归的运算。

影响流水线的因素

- 数据冲突（数据冒险）
  - 定义：下一条指令会用到这一条指令计算出的结果
  - 解决：
    - 暂停几个时钟周期，直到数据相关问题消失再继续执行。可分为硬件阻塞（stall）和软件“NOP”指令两种。
    - 设置相关专用通路；
    - 编译优化：调整指令顺序来解决数据相关；
- 控制冲突（控制冒险）
  - 定义：上一条需要用到预判下一条指令的位置。
  - 解决：
    - 对转移指令进行分支预测；
    - 加快和提前形成条件码；
    - 提高转移方向的猜准率；

#### 流水线的性能指标

流水线的吞吐率TP ：$TP = \frac n T_k$

- n 是任务数
- T~k~是处理完n 个任务所用的时间



流水线的加速比S：$S = \frac {T_0} {T_k}$

- T~0~表示顺序执行所需要的时间；
- T~k~表示使用流水线时的执行时间；



流水线的效率E：$E =\frac {n个任务占用的时空区面积}{n个任务所用的时间与k个流水段所围成的时空区总面积} = \frac{T_0}{kT_k} $



#### 超标量流水线

- 超标量流水线技术：不调整指令的执行顺序，指令编译优化，将可并行的指令搭配起来——>挖掘更多指令并行性；

  - ![image-20210927174719337](CPU.assets/image-20210927174719337.png)

    

- 超级流水线技术：不调整指令的执行顺序，指令编译优化，一个时钟周期内再分段没在一个时钟周期内一个功能部件使用多次。

  - ![image-20210927174835893](CPU.assets/image-20210927174835893.png)

    

- 超长指令字：编译优化指令的并行性，将多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字。

## 中央处理器

### CPU的基本结构以及其功能

![image-20210927175009260](CPU.assets/image-20210927175009260.png)

CPU 的具体功能包括：

- 指令控制：即程序的顺序控制。
- 操作控制：一条指令的功能往往由若干操作信号的组合来实现。
- 时间控制：对各种操作加以时间上的控制；
- 数据加工：ALU
- 中断处理：对计算机运行过程中出现的异常情况和特殊请求进行处理。

| 用户可见寄存器 |                       用户不可见寄存器                       |
| :------------: | :----------------------------------------------------------: |
|   其他寄存器   | 存储器地址寄存器（MAR）、存储器数据寄存器（MDR）、指令寄存器（IR），暂存寄存器 |

- 程序状态字寄存器（PSW）：保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息。如溢出标志(OF) 、符号标志(SF) 、零标志(ZF) 、进位标志(CF) 等。PSW 中的这些位参与并决定微操作的形成。
- 暂存寄存器：用于**暂存从主存读来的数据**，该数据不能存放在通用寄存器中，否则会破坏其原有内容。暂存寄存器对应用程序员是透明的。

### 数据通路

> - 数据通路：数据在功能部件之间传送的路径称为数据通路；
> - 数据通路部件：路径上的部件称为数据通路部件；

数据通路基本有分类：

- CPU 内部单总线方式：所有寄存器的输入端和输出端都连接到一条公共通路上，容易发生冲突；
- CPU 内部三总线方式：在多个总线上传送不同的数据，提高效率。
- 专用数据通路方式：根据指令执行过程中的数据和地址的流动方向安排连接线路，避免使用、共享的总线，性能较高，但硬件量大。

### CU — 控制器



控制器的主要功能：

- 从主存中取出一条指令，并指出下一条指令在主存中的位置。
- 对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作。
- 指挥并控制CPU、主存、输入和输出设备之间的数据流动方向。



控制器的构成有两种方式：

- 硬布线控制器
- 微程序控制器



#### 硬布线控制器(组合逻辑控制器)

![image-20210927175934214](CPU.assets/image-20210927175934214.png)

> - 由复杂的组合逻辑门电路和一些触发器构成；
> - 根据指令的要求、当前的时序及外部和内部的状态，按时间的顺序发送一系列微操作控制信号

CU 的输入信号来源：

1. 指令中的操作码 传递给 操作码译码器 产生的控制信号传递给CU；
2. 机器主频根据节拍发生器产生的脉冲信号传递给CU；
3. 第三方的反馈信号；
   1. 中断请求，DMA请求；



##### CPU 的控制方式

> 控制单元控制一条指令执行的过程，实质上是依次执行一个确定的**微操作序列**的过程；由于*不同指令所对应的微操作数以及复杂程度不同*，所以每条指令和每个微操作所需的执行时间也不同，从而诞生了CPU的控制方式：

主要有3中CPU控制方式：

1. 同步控制方式：由系统统一的时钟进行控制每个微操作所需的时间，以最长的微操作序列和最烦琐的微操作作为标准；
2. 异步控制方式：不存在基准时标信号，各部件按自身固有的速度工作，通过**应答方式**进行联络。
3. 联合控制方式：对各种不同的指令的微操作实行**大部分采用同步控制、小部分采用异步控制**的办法。

##### 硬布线控制单元设计步骤

$微操作控制信号＝ 机器周期 \ 节拍 \ 脉冲 \ 操作码 \ 机器状态条件$



#### 微程序控制器

> 核心思想：就是将每条机器指令编写成一个微程序，每个微程序包含若干微指令。每个微程序都存入专门的存储器中，微操作控制信号由微指令产生；

概念注意点：

- 机器指令对应一个微程序；
- 一个微程序 = N个位操作；
- 微操作是计算机最基本的，不可再分的操作；
- 存放微指令的控制存储器的单元地址称为微地址。
- 微周期：指从控制存储器中读取一条微指令并执行相应的微操作所需的时间。
- 微命令和微操作是一一对应的。微命令是微操作的控制信号，微操作是微命令的执行过程；
- 互斥性微命令是指在机器中不允许同时出现的微命令。
- 相容性微命令是指那些可以同时产生、共同完成某一些微操作的微命令。
- 控制存储器（CM）：CPU内部，用来存放微程序，用ROM实现。
- 微程序的结构和功能对程序员谁不可见的。



微地址 ——> 微指令 ——>微操作 ——>微程序 ——> 机器指令



##### 微程序控制器的工作过程

![image-20210927182826302](CPU.assets/image-20210927182826302.png)

1. 在机器开始运行时，自动将 **取指微程序** 的入口地址送入CMAR，并从CM 中读出相应的微指令送入CMDR。取指微程序的入口地址一般为CM 的0 号单元。当取指微程序执行完后，从主存中取出的机器指令就已存入指令寄存器中。
2. 由机器指令的操作码字段通过微地址形成部件产生该机器指令所对应的微程序的入口地址，并送入CMAR 。
3. 从CM 中逐条取出对应的微指令并执行。
4. 执行完对应千一条机器指令的一个微程序后，又回到取指微程序的入口地址， 继续第1步，以完成取下一条机器指令的公共操作。
