# CPU

[toc]



## 指令系统

### 指令格式

![image-20210927093133700](CPU.assets/image-20210927093133700.png)

- **地址码**：被操作的信息（指令或数据）的地址；
- **操作码**：指令中该指令应该执行什么性质的操作和具有何种功能；
- 指令字长取决于 操作码的长度 + 操作数地址码的长度和个数；



> ​	指令字长和指令字长的关系？
>
> 指令长度与机器字长没有固定的关系：
>
> - 单字长指令：指令长度 = 机器字长；
> - 半字长指令：指令长度 = $\frac{1}{2}$ 机器字长
> - 双字长指令：指令长度 = $2$ 机器字长



### 指令分类

| 名称       | 图解                                                         | 说明                                                         | 案例                                                         |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 零地址指令 | ![image-20210927101455274](CPU.assets/image-20210927101455274.png) | 仅用在堆栈计算机中：两个操作数隐含地从栈顶和次栈顶弹出，送到运算器进行运算，运算结果再隐含的压入堆栈。 | 空操作指令；停机指令；关中断指令；                           |
| 一地址指令 | ![image-20210927101735962](CPU.assets/image-20210927101735962.png) | 指令字长为32 位，操作码占8 位， 1个地址码字段占24 位，则指令操作数的直接寻址范围为2^24^ = 16M 。 | $0P(A_1)—>A_1$加1、减1、求反、求补指令                       |
| 二地址指令 | ![image-20210927111538793](CPU.assets/image-20210927111538793.png) | 若指令字长为32 位，操作码占8 位，两个地址码字段各占12 位， 则指令操作数的直接寻址范围为2^12^ = 4K 。 | $(A_1)0P(A_2)—>A_1$常用的算术和逻辑运算指令，往往要求使用两个操作数，需分别给出目的操作数和源操作数的地址，其中目的操作数地址还用于保存本次的运算结果； |
| 三地址指令 | ![image-20210927111714822](CPU.assets/image-20210927111714822.png) | 若指令字长为32 位，操作码占8 位， 3 个地址码字段各占8 位，则指令操作数的直接寻址范围为2^8^ = 256 | $(A_1)0P(A_2)—>A_3$若地址字段均为主存地址，则完成一条三地址需要4 次访问存储器（取指令1次，取两个操作数2 次，存放结果1 次）。 |
| 四地址指令 | ![image-20210927112021891](CPU.assets/image-20210927112021891.png) | 指令字长为32 位，操作码占8 位， 4 个地址码字段各占6 位，则指令操作数的直接寻址范围为2^6^ = 64 。 | $(A_1)0P(A_2) —>A3$, A~4~ 指出下一条将要执行指令的地址。     |



**分类二**

- **定长操作码指令格式**：最高位部分分配固定的若干位（定长）表示操作码。一般**n位操作码字段**的指令系统最大能够表示$2^n$ 条指令;
- **扩展操作码指令格式**: 指令长度不变，减少地址码的长度用作增加操作码的长度；
  - ![image-20210927112558500](CPU.assets/image-20210927112558500.png)
  - 要求：
    - 不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分的代码相同。
    - 各指令的操作码一定不能重复。
  - 说明：**使用频率高**的指令分配**较短的操作码**；

### 寻址



#### 指令寻址

指令寻址方式有两种：

-  顺序寻址方式：可通过程序计数器(PC) 加1 (1 个指令字长），自动形成下一条指令的地址；

-  跳跃寻址方式：通过转移类指令实现。

   - **下条指令的地址码由本条指令给出下条指令地址的计算方式**
   - 注意：是否跳跃可能受到状态寄存器和操作数的控制：
     - 跳跃到的地址分为绝对地址（由标记符直接得到）和相对地址（相对于当前指令地址的偏移量），跳跃的结果是当前指令修改PC 值，所以**下一条指令仍然通过程序计数器(PC) 给出**。

#### 数据寻址

> 如何在指令中表示一个操作数的地址。

  数据寻址的方式比较多，为了区别，在指令字段中设置一个字段，用来指明属于那种寻址方式：

![image-20210927113539664](CPU.assets/image-20210927113539664.png)

| 寻址名称       |                             图解                             | 说明                                                         |
| -------------- | :----------------------------------------------------------: | ------------------------------------------------------------ |
| 隐含寻址       | ![image-20210927113625168](CPU.assets/image-20210927113625168.png) | 单地址指令中其中另一个地址存在于ACC中；                      |
| 立即寻址       | ![image-20210927114259036](CPU.assets/image-20210927114259036.png) | 地址字段指出就是操作数本身，又称立即数                       |
| 直接寻址       | ![image-20210927114310020](CPU.assets/image-20210927114310020.png) | 指令在执行阶段仅访问一次主存，不需要专门计算操作数的地址；   |
| 间接寻址       | ![image-20210927114334463](CPU.assets/image-20210927114334463.png) | 指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址所在的存储单元的地址，也就是操作数地址的地址 |
| 寄存器寻址     | ![image-20210927114440050](CPU.assets/image-20210927114440050.png) |                                                              |
| 寄存器间接寻址 | ![image-20210927114458357](CPU.assets/image-20210927114458357.png) |                                                              |
| 相对寻址       | ![image-20210927114513597](CPU.assets/image-20210927114513597.png) | EA=(PC)+A ；A 是相对千当前指令地址的位移量，可正可负，补码表示， |
| 基址寻址       | ![image-20210927114639434](CPU.assets/image-20210927114639434.png) | EA= (BR)+ A 。其中基址寄存器既可采用专用寄存器，又可采用通用寄存器。面向操作系统的，其内容由操作系统或管理程序确定，主要用千解决程序逻辑空间与存储器物理空间的无关性，在程序执行过程中，基址寄存器的内容不变（作为基地址），形式地址可变（作为偏移量），采用通用寄存器作为基址寄存器时，可由用户决定哪个寄存器作为基址寄存器，但其内容仍由操作系统确定。因此有利于多道程序设计，并可用千编制浮动程序， |
| 变址寻址       | ![image-20210927114837403](CPU.assets/image-20210927114837403.png) | IX 为变址寄存器（专用），也可用通用寄存器作为变址寄存器。变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可由用户改变（作为偏移量），形式地址A 不变（作为基地址）。处理数组，优点是可扩大寻址范围。 |
| 堆栈寻址       |  寄存器堆栈又称硬堆栈；从主存中划出一段区域来做堆栈是软堆栈  | 堆栈存储器（或专用寄存器组）中一块特定的、按后进先出(LIFO) 原则管理的存储区；堆栈的地址是堆栈指针（SP）【特定的寄存器】给出。采用堆栈结构的计算机系统中，大部分指令表面上都表现为无操作数指令的形式，因为操作数地址都隐含使用了SP，在读／写堆栈中的一个单元的前后都伴有**自动**完成对SP内容的增量或减量操作。 |

![image-20210927114047846](CPU.assets/image-20210927114047846.png)



### CISC 和RISC

![image-20210927151031576](CPU.assets/image-20210927151031576.png)

### 指令执行过程

指令周期：CPU从主存中取出并执行一条指令的时间称作指令周期。

- 不同指令的指令周期不同；
- 1个指令周期 = n个机器周期 ； 一个机器周期 = m个时钟周期（节拍）



一个较为完整的指令周期：

![image-20210927161356368](CPU.assets/image-20210927161356368.png)

- 取指周期是为了取指令；
- 间址周期是为了取有效地址；
- 执行周期是为了取操作数；
- 中断周期是为了保存程序断点；

为了区别不同的工作周期，在CPU 内设置4 个标志触发器FE 、IND 、EX 和INT, 它们分别对应取指、间址、执行和中断周期，并以“1" 状态表示有效，分别由1——>FE 、1——>IND 、1——>EX和1——>INT 这4 个信号控制。

注意：中断周期中的进栈操作是将SP 减1, 这和传统意义上的进栈操作相反，原因是计算机的堆栈中都是向低地址增加，所以进栈操作是减1 而不是加1 。



### 指令流水线

> 一条指令周期通常包括几个时间段（执行步骤），每个步骤完成指令的一部分功能，几个步骤的配合完成整条指令功能。所以不同的步骤执行方案可以尽可能的节省性能和硬件成本。

- 方案一：单指令周期：对所有指令都选用**相同的执行时间**来完成；指令之间串行执行；
- 方案二：多指令周期：不同的步骤中采用自己的所需的时钟周期；指令之间串行执行；
- 方案三：指令流水线：指令之间可以并行执行；力争在**每个时钟脉冲周期完成一条指令的执行过程**；尽量让多条指令同时运行，但各自处在不同的执行步骤中。



注意：指令流水和指令周期中的步骤无关，指令流水在意的是力争在每一个时钟脉冲完成一条指令。



流水线的定义：将指令的执行过程分成多个阶段；

![image-20210927162431612](CPU.assets/image-20210927162431612.png)

- 取指（取址周期）：根据PC 内容访问主存储器，取出一条指令送到IR 中。
- 分析（间址周期）：对指令操作码进行译码，按照给定的寻址方式和地址字段中的内容形成操作数的有效地址EA, 并从有效地址EA 中取出操作数。
- 执行（指向周期）：根据操作码字段，完成指令规定的功能，即把运算结果写到通用寄存器或主存中。



执行方案的选取：

![image-20210927162628695](CPU.assets/image-20210927162628695.png)



$T = 3nt - 2（n-1）t$

其中：

- n是指令条数
- t是每个阶段所需时间
- (n -1)是折叠的部分数



流水线的特点：

- 每个部件后面都有一个缓存寄存器（锁存器），作用是保存本流水段的执行结构供给下一流水段使用；
- 流水线中各功能段的时间应尽量相等，否则将引起堵塞、断流。
- 流水线需要有装入时间和排空时间。

流水线的分类：

- 动态流水线和静态流水线
  - 静态流水线指在同一时间内，流水线的各段只能按同一种功能的连接方式工作。
  - 动态流水线指在同一时间内，当某些段正在实现某种运算时，另一些段却正在进行另一种运算。
- 线性流水线和非线性流水线
  - 线性流水线中，从输入到输出，每个功能段只允许经过一次，不存在反馈回路
  - 非线性流水线存在反馈回路，从输入到输出的过程中， 某些功能段将数次通过流水线，这种流水线适合进行线性递归的运算。

影响流水线的因素

- 数据冲突（数据冒险）
  - 定义：下一条指令会用到这一条指令计算出的结果
  - 解决：
    - 暂停几个时钟周期，直到数据相关问题消失再继续执行。可分为硬件阻塞（stall）和软件“NOP”指令两种。
    - 设置相关专用通路；
    - 编译优化：调整指令顺序来解决数据相关；
- 控制冲突（控制冒险）
  - 定义：上一条需要用到预判下一条指令的位置。
  - 解决：
    - 对转移指令进行分支预测；
    - 加快和提前形成条件码；
    - 提高转移方向的猜准率；

#### 流水线的性能指标

流水线的吞吐率TP ：$TP = \frac n T_k$

- n 是任务数
- T~k~是处理完n 个任务所用的时间



流水线的加速比S：$S = \frac {T_0} {T_k}$

- T~0~表示顺序执行所需要的时间；
- T~k~表示使用流水线时的执行时间；



流水线的效率E：$E =\frac {n个任务占用的时空区面积}{n个任务所用的时间与k个流水段所围成的时空区总面积} = \frac{T_0}{kT_k} $



#### 超标量流水线

- 超标量流水线技术：不调整指令的执行顺序，指令编译优化，将可并行的指令搭配起来——>挖掘更多指令并行性；

  - ![image-20210927174719337](CPU.assets/image-20210927174719337.png)

    

- 超级流水线技术：不调整指令的执行顺序，指令编译优化，一个时钟周期内再分段没在一个时钟周期内一个功能部件使用多次。

  - ![image-20210927174835893](CPU.assets/image-20210927174835893.png)

    

- 超长指令字：编译优化指令的并行性，将多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字。

## 中央处理器

### CPU的基本结构以及其功能

![image-20210927175009260](CPU.assets/image-20210927175009260.png)

CPU 的具体功能包括：

- 指令控制：即程序的顺序控制。
- 操作控制：一条指令的功能往往由若干操作信号的组合来实现。
- 时间控制：对各种操作加以时间上的控制；
- 数据加工：ALU
- 中断处理：对计算机运行过程中出现的异常情况和特殊请求进行处理。

| 用户可见寄存器 |                       用户不可见寄存器                       |
| :------------: | :----------------------------------------------------------: |
|   其他寄存器   | 存储器地址寄存器（MAR）、存储器数据寄存器（MDR）、指令寄存器（IR），暂存寄存器 |

- 程序状态字寄存器（PSW）：保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息。如溢出标志(OF) 、符号标志(SF) 、零标志(ZF) 、进位标志(CF) 等。PSW 中的这些位参与并决定微操作的形成。
- 暂存寄存器：用于**暂存从主存读来的数据**，该数据不能存放在通用寄存器中，否则会破坏其原有内容。暂存寄存器对应用程序员是透明的。

### 数据通路

> - 数据通路：数据在功能部件之间传送的路径称为数据通路；
> - 数据通路部件：路径上的部件称为数据通路部件；

数据通路基本有分类：

- CPU 内部单总线方式：所有寄存器的输入端和输出端都连接到一条公共通路上，容易发生冲突；
- CPU 内部三总线方式：在多个总线上传送不同的数据，提高效率。
- 专用数据通路方式：根据指令执行过程中的数据和地址的流动方向安排连接线路，避免使用、共享的总线，性能较高，但硬件量大。

### CU — 控制器



控制器的主要功能：

- 从主存中取出一条指令，并指出下一条指令在主存中的位置。
- 对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作。
- 指挥并控制CPU、主存、输入和输出设备之间的数据流动方向。



控制器的构成有两种方式：

- 硬布线控制器
- 微程序控制器



#### 硬布线控制器(组合逻辑控制器)

![image-20210927175934214](CPU.assets/image-20210927175934214.png)

> - 由复杂的组合逻辑门电路和一些触发器构成；
> - 根据指令的要求、当前的时序及外部和内部的状态，按时间的顺序发送一系列微操作控制信号

CU 的输入信号来源：

1. 指令中的操作码 传递给 操作码译码器 产生的控制信号传递给CU；
2. 机器主频根据节拍发生器产生的脉冲信号传递给CU；
3. 第三方的反馈信号；
   1. 中断请求，DMA请求；



##### CPU 的控制方式

> 控制单元控制一条指令执行的过程，实质上是依次执行一个确定的**微操作序列**的过程；由于*不同指令所对应的微操作数以及复杂程度不同*，所以每条指令和每个微操作所需的执行时间也不同，从而诞生了CPU的控制方式：

主要有3中CPU控制方式：

1. 同步控制方式：由系统统一的时钟进行控制每个微操作所需的时间，以最长的微操作序列和最烦琐的微操作作为标准；
2. 异步控制方式：不存在基准时标信号，各部件按自身固有的速度工作，通过**应答方式**进行联络。
3. 联合控制方式：对各种不同的指令的微操作实行**大部分采用同步控制、小部分采用异步控制**的办法。

##### 硬布线控制单元设计步骤

$微操作控制信号＝ 机器周期 \、 节拍 \ 脉冲 \ 操作码 \ 机器状态条件$



#### 微程序控制器

> 核心思想：就是将每条机器指令编写成一个微程序，每个微程序包含若干微指令。每个微程序都存入专门的存储器中，微操作控制信号由微指令产生；

概念注意点：

- 机器指令对应一个微程序；
- 一个微程序 = N个位操作；
- 微操作是计算机最基本的，不可再分的操作；
- 存放微指令的控制存储器的单元地址称为微地址。
- 微周期：指从控制存储器中读取一条微指令并执行相应的微操作所需的时间。
- 微命令和微操作是一一对应的。微命令是微操作的控制信号，微操作是微命令的执行过程；
- 互斥性微命令是指在机器中不允许同时出现的微命令。
- 相容性微命令是指那些可以同时产生、共同完成某一些微操作的微命令。
- 控制存储器（CM）：CPU内部，用来存放微程序，用ROM实现。
- 微程序的结构和功能对程序员谁不可见的。



微地址 ——> 微指令 ——>微操作 ——>微程序 ——> 机器指令



##### 微指令的格式

- 水平型微指令：从编码方式看，直接编码、字段直接编码、字段间接编码和混合编码都属于水平型微指令![image-20210928114655343](CPU.assets/image-20210928114655343.png)
- 垂直型微指令：类似机器指令操作码的方式
- 混合型微指令：在垂直型的基础上增加一些不太复杂的并行操作。微指令较短，仍便于编写；微程序也不长，执行速度加快。

平型微指令和垂直型微指令的比较如下：

- 水平型微指令并行操作能力强、效率高、灵活性强；垂直型微指令则较差。
- 水平型微指令执行一条指令的时间短； 垂直型微指令执行的时间长。
- 由水平型微指令解释指令的微程序，具有微指令字较长但微程序短的特点；垂直型微指令则与之相反，其微指令字较短而微程序长。
- 水平型微指令用户难以掌握，而垂直型微指令与指令比较相似，相对容易掌握。

##### 微程序控制器的工作过程

![image-20210927182826302](CPU.assets/image-20210927182826302.png)

1. 在机器开始运行时，自动将 **取指微程序** 的入口地址送入CMAR，并从CM 中读出相应的微指令送入CMDR。取指微程序的入口地址一般为CM 的0 号单元。当取指微程序执行完后，从主存中取出的机器指令就已存入指令寄存器中。
2. 由机器指令的操作码字段通过微地址形成部件产生该机器指令所对应的微程序的入口地址，并送入CMAR 。
3. 从CM 中逐条取出对应的微指令并执行。
4. 执行完对应千一条机器指令的一个微程序后，又回到取指微程序的入口地址， 继续第1步，以完成取下一条机器指令的公共操作。

##### 微指令的编码方式(微指令的控制方式)—— 操作码部分

> 如何对微指令的控制字段进行编码，以形成控制信号。编码的目标是在保证速度的情况下，尽量缩短微指令字长。

- 直接编码（直接控制）方式：无须进行译码， 微指令的微命令字段中每位都代表一个微命令。设计微指令时，选用或不选用某个微命令，只要将表示该微命令的对应位设置成1 或0 即可。每个微命令对应并控制数据通路中的一个微操作。

  ![image-20210928112755615](CPU.assets/image-20210928112755615.png)

- 字段直接编码方式：将微指令的微命令字段分成若干小字段；，每个字段独立编码，每种编码代表一个微命令且各字段编码含义单独定义，与其他字段无关；

  - 一般每个小段还要留出一个状态，表示本字段不发出任何微命令。因此，当某字段的长度为3 位时，最多只能表示7 个互斥的微命令，通常用000 表示不操作。
  - 把互斥性微命令组合在同一字段中；
  - 把相容性微命令组合在不同字段中；
  - ![image-20210928113121795](CPU.assets/image-20210928113121795.png)

- 字段间接编码方式（隐式编码）：一个字段的某些微命令需由另一个字段中的某些微命令来解释，由千不是靠字段直接译码发出的微命令

##### 微指令的地址形成方式



- 直接由微指令的下地址字段指出（断定方式）：微指令格式中设置一个下地址字段，由微指令的下地址字段直接指出后继微指令的地址
- 根据机器指令的操作码形成：微指令的地址由操作码经微地址形成部件形成。

实际上，微指令序列地址的形成方式还有以下几种：

1. 增量计数器法，即(CMAR) + 1-CMAR, 适用千后继微指令的地址连续的情况。
2. 根据各种标志决定微指令分支转移的地址。
3. 通过网络测试形成。
4. 由硬件直接产生微程序入口地址。



电源加电后，第一条微指令的地址可由专门的硬件电路产生，也可由外部直接向CMAR 输入微指令的地址，这个地址即为取指周期微程序的入口地址。



##### 动态微程序设计和毫微程序设计

- 动态微程序设计：能根据用户的要求改变微程序，采用可擦除、可编程只读存储器CEPROM) 。
- 毫微程序设计：主存取出的每条指令是由放在控制存储器中的微程序来解释执行的，通过控制线对硬件进行直接控制。若硬件不由微程序直接控制，而是通过存放在第二级控制存储器中的毫微程序来解释的，这个第二级控制存储器就称为毫微存储器，直接控制硬件的是毫微微指令。





##### 硬布线和微程序控制器的对比



![image-20210928121628100](CPU.assets/image-20210928121628100.png)

