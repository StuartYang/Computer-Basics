

[toc]

## 程序如何运行的？

在多道程序环境下，要使程序运行，必须先为之创建进程。而*创建进程的第一件事，便是将程序和数据装入内存*。如何将一个用户源程序变为一个可在内存中执行的程序，通常都要经过以下几个步骤：

1. 编译：自己写的Java文件；
2. 链接：链接后的结果是装入模块（自己写的Java文件 + 库文件）；
   1. 静态链接
   2. 装入时动态链接
   3. 运行时动态链接
3. 装入：由装入程序将**装入模块**装入内存；
   1. 绝对装入：逻辑地址与实际内存地址完全相同；
   2. 重定位装入：多个目标模块起始地址通常都从0开始
      1. 可重定位装入（静态重定位）：一个作业装入内存时，必须给它分配要求的全部内存空间，若没有足够的内存，则不能装入该作业；
      2. 动态运行时装入（动态重定位）：装入内存后的所有地址均为相对地址，运行时候才转换为绝对地址；程序运行不需要全部内存；
4. 运行

![image-20210914162338347](存储系统.assets/image-20210914162338347.png)


## OS的内存管理基本功能

- 内存空间的分配和回收
- 地址转换
- 内存空间的扩充
- 存储（内存）保护 



### 内存（存储）保护

> 定义：保证各道作业在各自的存储空间内运行，互不干扰。

做法：

1. 在CPU 中设置一对上、下限寄存器，存放用户作业在==主存中的下限和上限地址==，每当CPU要访问一个地址时，分别和两个寄存器的值相比，判断有无越界。
2. 采用重定位寄存器（或基址寄存器）和界地址寄存器（又称限长寄存器）来实现这种保护。
   1. 真实地址  = 基址寄存器 + 限长寄存器

![image-20210914165404848](存储系统.assets/image-20210914165404848.png)

### 内存空间的扩充

>  ==覆盖与交换==技术是在*多道程序*环境下用来扩充内存的两种方法。



#### 覆盖技术——单道程序PC

- 把用户空间分成一个固定区和若千覆盖区，经常活跃的部分放在固定区，其余的要访问时候再放入覆盖区。
- **内存中能够更新的地方只有覆盖区的段，不在覆盖区中的段会常驻内存。**

#### 交换技术 —— 多道程序PC

- 把处于等待状态的程序从内存移到辅存，这一过程又称换出；
- 把准备好竞争CPU 运行的程序从辅存移到内存，这一过程又称换入；

*进程管理中的中级调度算法就是交换技术的体现*

#### 覆盖和交换的对比

|   ---    |         交换         |         覆盖         |
| :------: | :------------------: | :------------------: |
| 适应场景 | 不同进程（作业）之间 |  同一程序（进程）中  |
|  透明度  |  对用户和程序员透明  | 对用户和程序员不透明 |
|   发展   |   单道程序（淘汰）   |  多道程序（发展中）  |



### 内存空间的分配和回收



#### 内存空间的分配

- 连续分配
  - 单一联系分配：分配到内存固定区域，只适合单任务系统
  - 固定分区分配：分配到内存中不同的固定区域，分区可以相等也可以不等
  - 动态分区分配
- 非连续分配
  - 基本分页存储管理          
  - 基本分段存储管理方式
  - 段页管理方式

##### 连续分配

> 定义：连续分配方式是指为一个用户程序分配一个连续的内存空间，例如：某用户需要1GB 的内存空间，连续分配方式就在内存空间中为用户分配一块连续的1GB 空间；
>
> - 低区（系统区）由操作系统使用，用户区是系统区之外的其他区域。

###### 单一连续分配

特点：

- 采用覆盖技术
- 只适用于单用户，单任务的操作系统中
- 存储器利用率低，有内部碎片

###### 固定分区分配

用户区划分若干固定大小的区域，每个区域只能装一道作业。单有空闲分区时，才能从后备队列中选择适当大小的作业装入该分区，如此循环。

分类：

- 分区大小相等的固定分区分配方式
- 分区大小不相等的固定分区分配方式
  - 需要有一张分区说明表，每次分配按表分配，如果没有找到合适的分区，就拒绝为该用户分配内存。

特点：

- 多道程序可以使用，但是多道程序不能共享一  个主存区



###### 动态分区分配（可变分区分配）

特点：

- 不预先分配内存，而是根据进程的大小动态建立分区

缺点：会有外部碎片，需要通过**紧凑技术**进行解决

动态分区的分配策略：

|           算法           | 说明                                                         | 性能 |
| :----------------------: | :----------------------------------------------------------- | ---- |
| 首次适应(First Fit) 算法 | 空闲分区以**地址从小到大**的次序链接。分配内存时顺序查找，找到大小能满足要求的第一个空闲分区。 | 最好 |
| 最佳适应(Best Fit) 算法  | 空闲分区按**容量从小到大**的方式形成分区链，找到第一个能满足要求的空闲分区。 | 居中 |
| 最坏适应(Worst Fit) 算法 | 空闲分区以**容量从小到大**的次序链接，找到第一个能满足要求的空闲分区，即挑选出最大的分区。 | 最差 |
| 邻近适应(Next Fit) 算法  | 首次适应算法的变体。不同之处是，分配内存时从上次查找结束的位置开始继续查找。 | -    |

###### 三种连续分配的比较

![image-20210917170708303](存储系统.assets/image-20210917170708303.png)



##### 非连续分配管理方式

> 非连续分配允许一个程序分散地装入不相邻的内存分区。
>
> - 但是依旧是，一个程序要是想运行，必须全部加载到内存中

###### 基本分页存储管理方式

> 目的：分页管理方式是从计算机的角度考虑设计的，目的是提高内存的利用率，提升计算机的性能。分页通过硬件机制实现，对用户完全透明。

**分页**： 把主存空间划分为**大小相等**且**固定的**块，块**相对较小**，作为主存的基本单位；

**页（page）**：进程中的块叫做页；

**页框/帧（Page Frame）**：内存中的块叫做页框；

**块（Block）**：外存的块直接叫做块；

**页表**：为了便千在内存中找到进程的每个页面所对应的物理块，系统为**每个进程建立一张页表**；

- 记录页面在内存中对应的物理块号
- 页表一般存放在内存中；



**逻辑地址**：用来估算大概需要多少字节空间

![image-20210917174237537](存储系统.assets/image-20210917174237537.png)

```
内存中最小的单位是页
但是计算机[一般情况下]寻址的单位是字节（B）

什么叫寻址的单位是字节？

计算机找的目标是字节，所以是按字节编址的，但是内存为了方便管理，就把内存区域分页。

```

- 页号P：逻辑（相对）上在那一页

- 页内偏移地址W：页内字节地址

**页表**

![image-20210917180627765](存储系统.assets/image-20210917180627765.png)

页表中的块号 +  逻辑地址的第二部分（页内偏移地址） = 真实的逻辑地址



**地址变换过程**

![image-20210917180758544](存储系统.assets/image-20210917180758544.png)



![image-20210917180806731](存储系统.assets/image-20210917180806731.png)

```
假设：
页面大小为L
逻辑地址A 
物理地址E
页表项中的内容b
```

*以下整个地址变换过程均是由硬件自动完成的：*

1. 计算页号P (P=A/L) 和页内偏移量W (W=A/L)
2. 比较页号P 和页表长度M, 若P > M, 则产生越界中断，否则继续执行。
3. 页表中页号P对应的`页表项地址`＝页表始址F+ 页号P x 页表项长度；这就计算出页表中页表项的物理块号。
   1. 页表长度的值是指一共有多少页；
   2. 页表项长度是指页地址占多大的存储空间；
4. 计算E=页表项中的内容b x L+ W, 用得到的物理地址E 去访问内存。
   1. b x L：相当于地址左移L位



> 32bite逻辑地址空间、字节编址单位、一页4KB为例：

一共内存大小：2^32^ B 

因为一页是4KB = 2^12^B，所以内存中一共有2^32^B/2^12^B = 2^20^ = 1M个页

现在研究页表：页表项中的内容是`页的物理地址`

又因为以字节作为编址单位，即页表项的大小之$$\lceil 20/8\rceil = 3B$$ ；

当然，也可选择更大的页表项让一个页面能够正好容下整数个页表项，进而方便存储（如取成4B ，一页正好可以装下lK 个页表项），或增加一些其他信息。



具有快表（TLB）【相联存储器】的分表机制：

![image-20210918160127548](存储系统.assets/image-20210918160127548.png)

1. CPU 给出逻辑地址后，由硬件进行地址转换，将页号送入高速缓存寄存器，并将此页号与快表中的所有页号进行比较。
2. 若找到匹配的页号，说明所要访问的页表项在快表中，则直接从中取出该页对应的页框号，与页内偏移量拼接形成物理地址。这样，存取数据仅一次访存便可实现。
3. 若未找到匹配的负号，则需要访问主存中的页表，在议出页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换。



###### 基本分段存储管理方式

> 分段管理方式的提出则考虑了用户和程序员，一以满足方便编程、信息保护和共享、动态增长及动态链接等多方面的需要。

分段：段式管理方式按照用户进程中的自然段划分逻辑空间。段内要求连续，段间不要求连续.

```c
例如:用户进程由主程序、两个子程序、栈和一段数据组成。
    
    于是可以把这个用户进程划分为5 段，每段从0 开始编址，并分配一段连续的地址空间（段内要求连续，段间不要求连续，因此整个作业的
地址空间是二维的），其逻辑地址由段号S 与段内偏移量W 两部分组成。
```

![image-20210918161238624](存储系统.assets/image-20210918161238624.png)

在图3.13 中，段号为16 位，段内偏移量为16 位，因此一个作业最多有2^16^ = 65536 段，最大段长2^14^ = 64KB



> 在页式系统中，逻辑地址的页号和页内偏移量对用户是透明的，但在段式系统中，段号和段内偏移量必须由用户显式提供，在高级程序设计语言中，这个工作由编译程序完成。

![image-20210918161410393](存储系统.assets/image-20210918161410393.png)

1. 逻辑地址A 中取出前几位为段号S, 后几位为段内偏移量W, 注意在段式存储管理的题目中，逻辑地址一般以二进制数给出，而在页式存储管理中，逻辑地址一般以十进制数给出，读者要具体问题具体分析。
2. 比较段号S 和段表长度M, 若S>=M, 则产生越界中断，否则继续执行。
3. 段表中段号S 对应的 段表项地址＝段表始址F+ 段号S x 段表项长度，取出该段表项的前几位得到段长C。若段内偏移量>= C, 则产生越界中断，否则继续执行。从这句话我们可以看出，段表项实际上只有两部分，前几位是段长，后几位是始址。
4. 取出段表项中该段的始址b, 计算E=b+ W, 用得到的物理地址E 去访问内存。



段的共享和保护：

只有不能修改的代码或者数据才能被共享，而可以修改的代码的数据不能共享。其中不能修改的代码叫做纯代码或可重入代码。



段式管理与页式管理不同，段式管理不能通过给出一个整数便确定对应的物理地址，因为每段的长度是不固定的，无法通过整数除法得出段号，无法通过求余得出段内偏移，所以段号和段内偏移一定要显式给出（段号，段内偏移），因此分段管理的地址空间是二维的。



###### 段页式管理方式

![image-20210918162305438](存储系统.assets/image-20210918162305438.png)

段页式的逻辑地址结构：

![image-20210918162324321](存储系统.assets/image-20210918162324321.png)



注意在一个进程中，段表只有一个，而页表可能有多个。



##### 虚拟内存

传统存储管理的特征：

1. 一次性：作业必须一次性全部装入内存后，才能开始运行。
2. 驻留性：作业被装入内存后，就一直驻留在内存中，其任何部分都不会被换出，直至作业运行结束。



局部性原理：

- 时间局部性：程序中的某条指令一旦执行，不久后该指令可能再次执行
- 空间局部性：一旦程序访问了某个存储单元，在不久后，其附近的存储单元也将被访问。



虚拟内存的特征：

1. 多次性：作业运行时允许被分成多次调入内存运行。
2. 对换新：允许在作业的运行过程中，进行换进和换出。
3. 虚拟性：虚拟性是指从逻辑上扩充内存的容量，使用户所看到的内存容量远大于实际的内存容量。

虚拟内存的实现有以下三种方式：

1. 请求分页存储管理；
2. 请求分段存储管理；
3. 请求段页式存储管理；



虚拟内存的实现需要以下硬件的支持：

1. 一定容量的内存和外存；
2. 页表机制（段表），作为主要的数据结构；
3. 中断机构，当用具程序要访问的部分还没有调入内存时，则产生中断；
4. 地址变换机构，逻辑地址<——>物理地址的变换。

###### 请求分页管理方式

页表机制：![image-20210918163211522](存储系统.assets/image-20210918163211522.png)

> 在传统的页表中加入其它成分：
>
> - 状态位P：用千指示该页是否已调入内存，供程序访问时参考。
> - 访问字段A ：用于记录本页在一段时间内被访问的次数，或记录本页最近已有多长时间未被访问，供置换算法换出页面时参考；
> - 修改位M：标识该页在调入内存后是否被修改过；
> - 外存地址：用千指出该页在外存上的地址，通常是物理块号，供调入该页时参考。



缺页中断机制

每当所要访问的页面不在内存中时，便产生一个缺页中断，请求操作系统将所缺的页调入内存。此时应将缺页的进程阻塞（调页完成唤醒），若内存中有空闲块，则分配一个块，将要调入的页装入该块，并修改页表中的相应页表项，若此时内存中没有空闲块，则要淘汰某页（若被淘汰页在内存期间被修改过，则要将其写回外存）。

缺页中断作为中断，同样要经历诸如保护CPU 环境、分析中断原因、转入缺页中断处理程序、恢复CPU 环境等几个步骤。但与一般的中断相比，它有以下两个明显的区别：

- 在*指令执行期间*而非一条指令执行完后产生和处理中断信号，属于内部中断。
- 一条指令在执行期间，可能产生多次缺页中断。



地址变换

1. 在进行地址变换时，先检索快表：

   1. 若找到要访问的页，则修改页表项中的访问位（写指令还需要重猩修改位），然后利用页表项中给出的物理块号和页内地址形成物理地址。
   2. 芒未找到该页的页表项，则应到内存中去查找页表，百对比页表项中的状态位P, 看该页是否已调入内存，未调入则产生缺页中断，请求从外存把该页调入内存。

   

![image-20210918163628360](存储系统.assets/image-20210918163628360.png)



###### 页面置换算法

- 先进先出(FIFO) 页面置换算法：优先淘汰最早进入内存的页面；
- 最近最久未使用（LRU）置换算法：选择最近最长时间未访问过的页面予以淘汰。—— 不可能实现
- 时钟(CLOCK) 置换算法：
- 改进型CLOCK 算法



###### 页面分配策略

> 进程第一次准备执行时，不需要也不可能把一个进程的所有页都读入主存。因此，操作系统必须决定读取多少页，即决定给特定的进程分配几个页框。
>
> - 驻留集：给一个进程分配的物理页框的集合就是这个进程的驻留集。



策略：

- 固定分配局部置换：每个进程分配一定数目的物理块，再次更换的时候在自己固定的区域更换；
- 可变分配全局置换：系统中的每个进程分配一定数目的物理块，操作系统自身也保持一个空闪物理块队列。当某进程发生缺页时，系统从空闲物理块队列中取出一个物理块分配给该进程。
- 可变分配局部置换：固定分区局部置换 + 若进程在运行中频繁地缺页，则系统再为该进程分配若干物理块。



什么时候从外存将页面调入内存？

- 预调页策略：运行前的调入
- 请求调页策略：运行期间调入

一般情况下，两种调页策略会同时使用。



从（外存）哪调入页面？

外存分为两部分

- 存放文件的文件区——离散分配方式，速度慢
- 存放对换页面的对换区—— 采用连续分配方式，速度快



所以：

1. 如果系统拥有足够的对换区空间，可以全部从对换区调入。
2. 如果系统缺少足够的对换区空间，不会被修改的文件都直接从文件区调入；对于那些可能被修改的部分，将它们换出时必须调到对换区，
3. UNIX 方式：进程有关的文件都放在文件区，未运行过的页面都应从文件区调入；经运行过但又被换出的页面，由于放在对换区，因此下次调入时应从对换区调入。共享页面作为不能同的页面，也是在文件区进行对换。



###### 工作集

>  工作集是指在某段时间间隔内，进程要访问的页面集合。

![image-20210918165826188](存储系统.assets/image-20210918165826188.png)

上图中，`工作窗口`大小为5；

在t1时刻进程的工作集为{2,3,5}；

在t2时刻进程的工作集为{1,2,3,4}；



##  存储系统（机组）

### 存储介质

#### 随机存储器（RAM）

##### 静态随机存储器（SRAM）

- 材料：双稳态`触发器`（六晶体MOS）
  - 不需要再生状态（非破坏性）

- 特点：速度快，但集成度低，功耗较大

- 用途：一般用来组成高速缓冲存储器（Cache）。

#####  动态随机存储器（DRAM）

- 材料：放电电容
  - 需要充放电
- 特点：
  - 地址复用技术：地址线是原来的1/2，地址信号分行，列两次传送；
  - 集成度高
  - 容量大
  - 功耗低
  - 存取速度慢
- 用途：用做主存

常用的三种刷新方式：

1. 集中刷新：在一个刷新周期内，利用一段固定的时间，依次对存储器的所有行进行逐`行`刷新；
2. 分散刷新：一个存储器的系统工作周期分为两部分：前半部分用千正常读、写或保持；后半部分用千刷新某一行。
   1. 这种刷新方式增加了系统的存取周期，如存储芯片的存取周期为0 . 5μs, 则系统的存取周期为lμs 。
   2. 优点是没有死区；
3. 异步刷新：利用逻辑电路每隔时间t 产生一次刷新请求。
   1. 如果将刷新安排在不需要访问存储器的译码阶段，就不会产生“ 死时间”，称为＂透明刷新”。



DRAM 的刷新需注意以下问题： 

- 刷新对`CPU 是透明`的，即刷新不依赖外部的访问； 
- `刷新单位是行`，因此刷新操作时仅需要行地址；
- 刷新操作仅给栅极电容补充电荷，`不需要信息输出`。
- 刷新时不需要选片，即整个存储器中的所有芯片同时被刷新。



##### 总结

![image-20210918174339148](存储系统.assets/image-20210918174339148.png)



注意易失性存储器和刷新的区别：

- 易失性存储器是指断电后数据丢失 SRAM 和DRAM 都满足断电内容消失，但需要刷新的只有DRAM, 而SRAM 不需要刷新。

##### 只读存储器（ROM）

特点：

- 结构简单，所以位密度比可读写存储器的高。
- 具有非易失性（断点不丢失），所以可靠性高。



### 主存的结构

![image-20210918174515833](存储系统.assets/image-20210918174515833.png)

- 记忆单元（ 存储元件）构成的存储矩阵（存储体）；
  - 一个存储元件存放一个1或者0；
- 存储矩阵（也称存储体）构成是存储器的核心部分；
- 编址单位：具有`相同地址的那些存储元件构成的一个单位`，可以按字节编址
  - 现代计算机通常采用字节编址方式，此时存储体内的一个地址中有1 字节
- MAR是单向的
- MDR是双向的
- 数据线数和地址线数共同反映存储体容量的大小，图中中芯片的容量＝ 2^36^x64 位;
  - 地址线36根，数据线64根

### 性能指标

- 存储容量＝存储字数x 字长（ 如：1M x 8 位） 
- 存储速度：数据传输率＝数据的宽度／存储周期。
  -  存取时间(Ta ) ：存取时间是指从启动一次存储器操作到完成该操作所经历的时间。
  -  存取周期(Tm) ：存取周期又称`读写周期`或`访问周期`。它是指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立访问存储器操作（读或写操作）之间所需的最小时间间隔。
  -  主存带宽：主存带宽又称数据传输率，表示每秒从主存进出信息的最大数量，单位为字／秒、字节／秒（B/s） 或位／秒（b/s） 

![image-20210918172904306](存储系统.assets/image-20210918172904306.png)

### 多级存储系统

![image-20210918172947991](存储系统.assets/image-20210918172947991.png)

- Cache-主存：解决CPU和主存速度不匹配的问题；
- 主存-辅存：存储系统容量问题





### 主存和CPU的连接

![image-20210918175125617](存储系统.assets/image-20210918175125617.png)

### 主存容量的扩展

#### 位扩展法

#### 字扩展法

### 字位同时扩展



### 存储芯片的地址分配和片选



### 提高CPU访问存储器速度的方法



### Cache

#### Cache的工作原理

#### Cache与主存的映射方式

#### Cache中驻村块的替换算法

#### Cache写策略







